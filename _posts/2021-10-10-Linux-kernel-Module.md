---
layout: post
title:  "Writing Loadable Kernel Module"
subtitle: "Example of loadable kernel module using proc file system and concurrency control"
date:   2021-10-10 17:10:25 +0530
categories: [linux,system,kernel]
---

## What is loadable kernel module ?

Loadable kernel module or lkm can be thought of as a piece of code that can extend the functionalities of kernel.  
Why we need to extend the kernel, kernel already comes with all the functionalities I need. So, here are some use cases where you need to extend your kernel (Certainly it is not for a normal user).  

* Device drivers - The kernel uses it to communicate with that piece of hardware
without having to know any details of how the hardware works.  

* Filesystem drivers - A filesystem driver interprets the contents of a filesystem as
files and directories and such.

* System calls - Most system calls are built into the base kernel. But you can invent
a system call of your own and install it as an LKM.
Or you can override an existing system call with an LKM of your own.
 
* Network drivers - A network driver interprets a network protocol.


One can argue that why we need it after all we can modify kernel code ourselves and rebuild the kernel.
Yeah sure, if you have ample time in your hand, you always write perfect code and you do not care about portability, go ahead and do it. If there is a single bug in your code it can prevent kernel from booting up.  
To avoid all these issues loadable kernel module is required. 

## Hello World

Now, let us write a **helloworld.c** loadble kernel module.  
Some points to keep in mind while writing loadable kernel module:
* No libc modules. Invoke a function only if
it is available in the kernel.
* Use static function to avoid namespace
pollution.
* Be careful about kernel space and user
space.
* Take care of concurrency in the kernel. Use mutex locks and semaphores wherever required.

```c++
#include <linux/init.h>
#include <linux/module.h>
MODULE_LICENSE("GPL");
MODLUE_AUTHOR("AOS")
static int hello_init(void)
{
printk(KERN_ALERT "Hello, world\n");
return 0;
}
static void hello_exit(void)
{
printk(KERN_ALERT "Goodbye, you awesome people\n");
}
module_init(hello_init);
module_exit(hello_exit);
```
**hello_init** is called when we load the code in the kernel. Similarly, **hello_exit** is called when we unload the code from the kernel.  
One may ask, What do you mean by loading and unloading from the kernel. We have to first build a Makefile.

```make
obj-m+=lkm_18CS30007.o

all:
	make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build/ M=$(PWD) clean
```
* After doing make we would get **helloworld.ko**.We would load this kernel object file.  
* To Load we will use ```sudo insmod helloworld.ko```. After loading we can see "Hello World" message in ```dmesg```. Dmesg have messages that are generated by the kernel. It helps in monitoring proper working of the kernel.  
* To unload we will use ```sudo rmmod helloworld```. After unloading Goodbye message can be seen in ```dmesg```.  
* To see what are the lkm's present in your system you can do ```lsmod``` which lists currently loaded LKM's.

## Information Passing in LKM

To be able to communicate between any kernel module and user program we need a file system. This filesystem is called **proc filesystem**.  
Proc filesystem is a special filesystem that presents information about processes and other system information.  
Here is a minimal example. 

``` c++
#include <linux/init.h>
#include <linux/module.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("aaru");
MODULE_VERSION("0.01");

#define DEVICE_NAME "minimal_proc_lkm"

static const struct proc_ops file_ops =
{
	.proc_write = dev_write,
};

static ssize_t dev_write(struct file *file, const char* buf, size_t count, loff_t* pos) 
{
	printk("%s",buf);
	return count;
}

static int hello_init(void)
{
	struct proc_dir_entry *entry = proc_create(DEVICE_NAME, 0666, NULL, &file_ops);
	if (!entry)
		return -ENOENT;

	printk(KERN_ALERT DEVICE_NAME": Hello procfile is created\n");
	return 0;
}

static void hello_exit(void)
{
	remove_proc_entry(DEVICE_NAME, NULL);
	printk(KERN_ALERT"goodbye\n");
}
```
Every time a user program writes into **minimal_proc_lkm** it will be written in **dmesg**. Similarly, we can modify open, read, release, etc.

## Full Fledged example

Here we make a dummy LKM with information passing and concurrency control.

A userspace process will interact with the LKM in the following manner.  
1. It will open the file **/proc/full_ex** in read-write mode.
2. It will write one byte of data to the file to initialize the size of dequeue.
	* The first byte should contain the maximum capacity N of the deque. The size N should be
in between 1 to 100 (including 1 and 100). Other than these values produce an EINVAL
error, and LKM left uninitialized.
 
3. Next, write calls should pass integers to be inserted in the queue. LKM will insert the integer on left if it's odd and to the right otherwise. LKM must produce an invalid argument error in case of wrong argument. On a successful write call, LKM will return the number of bytes written (4bytes for 32-bit integers). LKM will produce EACCES error for any excess write calls and return -1.
4. As integers are written one by one in Step 3, they are inserted into the deque. In between, there might also be intermediate read calls explained in Step 5.
5. Read calls should read the integer from left only. LKM will produce EACCES error for any excess read calls (Dequeu is empty). In case of a successful call, it will return the number of bytes read (4 bytes), and in case of an error, it will return -1.
6. Userspace process closes the file.  

LKM should be able to handle concurrency and separate data from multiple processes. Also, no userspace
program should be able to open the file more than once simultaneously. However, the userspace process
should be able to reset the LKM (for the said process) by reopening the file. LKM needs to free up any
resources it allocated for the process when it (the process) closes the file.

First we define all the struct's that we need and function prototypes that we are going to use.
```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/mutex.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("aaru");
MODULE_VERSION("0.01");

#define DEVICE_NAME "full_ex"

//defined mutex for concurrency control
static DEFINE_MUTEX(deq_mutex);

//Dequeue Structure implemented as circular queue
//Rear is the left end here and front is the right end
struct Dequeue{
	int32_t *arr;
	int32_t capacity;
	int32_t front;
	int32_t rear;
};
typedef struct Dequeue Dequeue;

//Structure for hash_table
//Key -> pid of the process
//Value -> Dequeue corresponding to the process id
struct h_struct {
	int key;
	Dequeue* dq_head;
	struct h_struct* next;
};
//Head of the hash_table
struct h_struct *htable;

/*
	key_add -> function to add node in hash_table
	get_entry_from_key -> given pid of the process find dequeue corresponding to it
	key_del -> given pid of the process delete node corresponding to it from htable
	DestroyHashTable -> Delete the whole hash_table
*/

static void key_add(struct h_struct* entry);
static struct h_struct* get_entry_from_key(int key);
static void key_del(int key);
static void DestroyHashTable(void);

/*
	Helper functions for Dequeue operations
*/
static Dequeue *CreateDequeue(int32_t capacity);
static Dequeue* DestroyDequeue(Dequeue *h);
static void insertFront(Dequeue* h,int32_t key);
static void insertRear(Dequeue* h,int32_t key);
static int32_t insert(Dequeue* h,int32_t key);
static void delete_rear(Dequeue* h);
static int32_t get_rear(Dequeue* h);

/*
	Functions to modify open,read,write and release
*/
static int     new_open(struct inode *, struct file *);
static int     new_release(struct inode *, struct file *);
static ssize_t new_read(struct file *, char *, size_t, loff_t *);
static ssize_t new_write(struct file *, const char *, size_t, loff_t *);
static const struct proc_ops file_ops =
{
	.proc_open = new_open,
	.proc_read = new_read,
	.proc_write = new_write,
	.proc_release = new_release,
};
```

Next, we define all the hashtable operations. To handle concurrency we apply mutex locks on hashtable operations. Since each process has a separate dequeue we would not require further locking. One can apply mutex operations of new_read and new_write functions separately but it may slow down the execution. 
```c
//Adding key in the hashtable
static void key_add(struct h_struct* entry) 
{
	mutex_lock(&deq_mutex);
	entry->next = htable->next;
	htable->next = entry;
	mutex_unlock(&deq_mutex);
}

//Given key find the Dequeue corresponding to it
static struct h_struct* get_entry_from_key(int key) 
{
	struct h_struct* temp;
	mutex_lock(&deq_mutex);
	temp = htable->next;
	while (temp != NULL) {
		if (temp->key == key) {
			mutex_unlock(&deq_mutex);
			return temp;
		}
		temp = temp->next;
	}
	mutex_unlock(&deq_mutex);
	return NULL;
}

//given pid of the process delete node corresponding to it from hashtable
static void key_del(int key) 
{
	struct h_struct *prev, *temp;
	mutex_lock(&deq_mutex);
	prev = temp = htable;
	temp = temp->next;

	while (temp != NULL) 
	{
		if (temp->key == key) 
		{
			prev->next = temp->next;
			temp->dq_head = DestroyDequeue(temp->dq_head);
			temp->next = NULL;
			printk("PID %d <key_del> Kfree key = %d", current->pid, temp->key);
			kfree(temp);
			break;
		}
		prev = temp;
		temp = temp->next;
	}
	mutex_unlock(&deq_mutex);
}

/* Destroy Linked List of processes */
static void DestroyHashTable(void) 
{
	struct h_struct *temp, *temp2;
	temp = htable->next;
	htable->next = NULL;
	while (temp != NULL) 
	{
		temp2 = temp;
		printk("<DestroyHashTable> Kfree key = %d", temp->key);
		temp = temp->next;
		DestroyDequeue(temp2->dq_head);
		kfree(temp2);
	}
	kfree(htable);
}
```

Here, we define all the operations related to dequeue. We have implemented dequeue as a circular queue.
```c
//Create Dequeue of the given capacity
static Dequeue *CreateDequeue(int32_t capacity)
{
	Dequeue *h = (Dequeue*)kmalloc(sizeof(Dequeue),GFP_KERNEL);
	
	if(h==NULL)
	{
		printk(KERN_ALERT DEVICE_NAME ": PID %d Error in allocating Dequeue!",current->pid);
		return NULL;
	}

	h->capacity = capacity;
	h->front = -1;
	h->rear = 0;
	h->arr = (int32_t*)kmalloc_array(capacity,sizeof(int32_t),GFP_KERNEL);

	if(h->arr == NULL)
	{
		printk(KERN_ALERT DEVICE_NAME": PID %d Error in allocating Dequeue!",current->pid);
		return NULL;
	}
	return h;
}

//Destroy given Dequeue and free memory 
static Dequeue* DestroyDequeue(Dequeue *h)
{
	if(h==NULL)
		return NULL;
	printk(KERN_INFO DEVICE_NAME ": PID %d, %d bytes of Dequeue->arr Space freed.\n", current->pid, h->capacity);
	kfree(h->arr);
	kfree(h);
	return NULL;
}

//Helper function to insert in the front of Dequeue
static void insertFront(Dequeue* h,int32_t key)
{
	if(h->front==-1)
	{
		h->front = 0;
		h->rear = 0;
	}

	else if(h->front==0)
		h->front = h->capacity - 1;
	else
		h->front -= 1;
	h->arr[h->front] = key;
}

//Helper function to insert in the rear of the Dequeue
static void insertRear(Dequeue* h,int32_t key)
{
	if(h->front==-1)
	{
		h->front = 0;
		h->rear = 0;
	}

	else if(h->rear==h->capacity-1)
		h->rear = 0;
	else
		h->rear += 1;
	h->arr[h->rear] = key;
}


//Function to insert in the Dequeue
static int32_t insert(Dequeue* h,int32_t key)
{
	//If given dequeue is not full
	if(!((h->front == 0 && h->rear == h->capacity-1)||
		(h->front == h->rear + 1)))
	{
		//If even insert in the front
		if(key%2==0)
			insertFront(h,key);

		//If odd insert in the rear
		else
			insertRear(h,key);
	}

	//Return error code if dequeue is full
	else
		return -EACCES;
	return 0;
}

//Function to delete rear end of the given dequeue
void delete_rear(Dequeue *h)
{
	if(h->front==h->rear)
	{
		h->front = -1;
		h->rear = -1;
	}

	else if(h->rear==0)
		h->rear = h->capacity-1;
	else
		h->rear -= 1;
}

//Function to get the rear element and delete rear element from the dequeue
static int32_t get_rear(Dequeue *h)
{
	int32_t rear_idx = h->rear;
	delete_rear(h);
	return h->arr[rear_idx];
}
```

Here are all the modified file operations with proper checks since we cannot trust the userspace programm.
```c
static ssize_t new_write(struct file *file, const char* buf, size_t count, loff_t* pos) 
{
	int32_t args_set, dequeue_size, num, ret, buffer_len;
	static char buffer[256] = {0};
	char arr[4];
	struct h_struct *entry = NULL;

	if(buf==NULL || count<=0)
	{
		printk(KERN_ALERT DEVICE_NAME ":PID %d invalid arguments given",current->pid);
		return -EINVAL;
	}

	//copy buf to buffer to check if memory in buf is accessible
	if (copy_from_user(buffer, buf, count < 256 ? count : 256))
	{	
		printk(KERN_ALERT DEVICE_NAME ":PID %d write buffer is invalid",current->pid);
		return -ENOBUFS;
	}


	//Check if there is a node corresponding to current pid 
	entry = get_entry_from_key(current->pid);
	if(!entry)
	{
		printk(KERN_ALERT DEVICE_NAME ": PID %d RAISED ERROR in new_write entry is non-existent", current->pid);
		return -EACCES;
	}

	//Set flag if the dequeue is already initialized with size
	args_set = (entry->dq_head) ? 1 : 0;
	buffer_len = count < 256 ? count : 256;

	//If dequeue is initialized
	if(args_set)
	{
		//If given count is not equal to 4 return error
		if (count != 4) 
		{
			printk(KERN_ALERT DEVICE_NAME ": PID %d WRONG DATA SENT. %d bytes", current->pid, buffer_len);
			return -EINVAL;
		}

		
		//Convert buf into integer and store in num
		memset(arr, 0, 4 * sizeof(char));
		memcpy(arr, buf, count * sizeof(char));
		memcpy(&num, arr, sizeof(num));
		printk(DEVICE_NAME ": PID %d writing %d to Dequeue\n", current->pid, num);

		//Insert num into dequeue
		ret = insert(entry->dq_head,num);
		
		//if dequeue is already full return error
		if(ret<0)
		{	
			printk(KERN_ALERT DEVICE_NAME ":PID %d Dequeue is full",current->pid);
			return -EACCES;
		}

		//Return number of bytes written
		return sizeof(num);
	}

	//if given bytes is not equal to 1 return error
	if(buffer_len!=1)
	{
		return -EACCES;
	}

	dequeue_size = buf[0];
	printk(DEVICE_NAME ": PID %d DEQUEUE SIZE: %d", current->pid, dequeue_size);

	//Return erroe if given size<=0 or >100
	if(dequeue_size<=0 || dequeue_size>100)
	{
		printk(KERN_ALERT DEVICE_NAME ": PID %d Wrong size of Dequeue- %d!!\n", current->pid, dequeue_size);
		return -EINVAL;
	}

	//Destroy dequeue since new dequeue has to initialized
	entry->dq_head = DestroyDequeue(entry->dq_head);

	//Create new Dequeue
	entry->dq_head = CreateDequeue(dequeue_size);

	//return number of bytes written in deque
	return buffer_len;
}

static int new_open(struct inode *inodep, struct file *filep)
{
	struct h_struct *entry = NULL;

	//Return error if the dequeue corresponding to current process is already opened
	if (get_entry_from_key(current->pid) != NULL) 
	{
		printk(KERN_ALERT DEVICE_NAME ": PID %d, Tried to open twice\n", current->pid);
		return -EACCES;
	}
	
	//Inintialize node in the hash_table corresponding to current pid	
	entry = kmalloc(sizeof(struct h_struct), GFP_KERNEL);
	*entry = (struct h_struct) {current->pid, NULL, NULL};
	
	printk(DEVICE_NAME ": PID %d !!!! Adding %d to HashTable\n", current->pid, entry->key);
	key_add(entry);	
	return 0;	

}

static ssize_t new_read(struct file *file, char* buf, size_t count, loff_t* pos)
{
	int32_t args_set,rear_val,retval;
	struct h_struct *entry = NULL;

	if(buf==NULL || count<=0)
	{
		return -EINVAL;
	}
	
	entry = get_entry_from_key(current->pid);
	
	//if no node exists corresponding to current process return error
	if(entry==NULL)
	{
		printk(KERN_ALERT DEVICE_NAME "PID %d RAISED ERROR in new_read entry is non-existent", current->pid);
		return -EACCES;
	}

	//Set flag if the dequeue is null or not
	args_set = (entry->dq_head) ? 1 : 0;

	//If dequeue is null return error
	if(!args_set)
	{
		printk(KERN_ALERT DEVICE_NAME ": PID %d Dequeue not initialized",current->pid);
		return -EACCES;
	}

	//If dequeue is empty return error
	if(entry->dq_head->front==-1)
	{
		return -EACCES;
	}

	//get the left most element from the dequeue
	rear_val = get_rear(entry->dq_head);
	printk(DEVICE_NAME ": PID %d asking for %ld bytes\n", current->pid, count);
	
	//Copy rear_val to buf 
	retval = copy_to_user(buf, (int32_t*)&rear_val, count < sizeof(rear_val) ? count : sizeof(rear_val));

	//if Succesfully copied return number of bytes sent
	if(!retval)
	{
		printk(KERN_INFO DEVICE_NAME ": PID %d Sent %ld chars with value %d to the user\n", current->pid, sizeof(rear_val), rear_val);
		return sizeof(rear_val);
	}

	//else return error code
	else
	{
		printk(KERN_INFO DEVICE_NAME ": PID %d Failed to send retval : %d, Rear Value is %d\n", current->pid, retval, rear_val);
		return -EACCES; 
	}

}

//Remove process from hash_table after all operations
static int new_release(struct inode *inode, struct file *file) 
{
	
	key_del(current->pid);
	printk(KERN_INFO DEVICE_NAME ": PID %d Device successfully closed\n", current->pid);
	return 0;
}
```

Initializing and Exiting from lkm
```c
static int lkm_init(void)
{
	struct proc_dir_entry *entry = proc_create(DEVICE_NAME, 0, NULL, &file_ops);
	if (!entry)
		return -ENOENT;
	htable = kmalloc(sizeof(struct h_struct),GFP_KERNEL);
	*htable = (struct h_struct){-1,NULL,NULL};
	printk(KERN_ALERT DEVICE_NAME": procfile is created\n");
	mutex_init(&deq_mutex);
	return 0;
	
}

static void lkm_exit(void)
{
	mutex_destroy(&deq_mutex);
	DestroyHashTable();
	remove_proc_entry(DEVICE_NAME, NULL);
	printk(KERN_ALERT DEVICE_NAME": Removed Procfile\n");
}

module_init(lkm_init);
module_exit(lkm_exit);
```

To run the above code the previous makefile will work just fine. To test the above code we have to write a userspace program to test all the functionalities. That, I will leave to you.
Anyway, I will upload userspace program on my github. 

## Supplementary 

1. [https://www.iitg.ac.in/asahu/cs421/books/LKM2.6.pdf](https://www.iitg.ac.in/asahu/cs421/books/LKM2.6.pdf)

2. [https://www.xml.com/ldd/chapter/book/](https://www.xml.com/ldd/chapter/book/)

3. [https://www.oreilly.com/openbook/linuxdrive3/book/](https://www.oreilly.com/openbook/linuxdrive3/book/)

4. [https://www.tldp.org/HOWTO/Module-HOWTO/index.html](https://www.tldp.org/HOWTO/Module-HOWTO/index.html)

5. [https://lasr.cs.ucla.edu/classes/111_fall16/readings/dynamic_modules.html](https://lasr.cs.ucla.edu/classes/111_fall16/readings/dynamic_modules.html)

6. [http://derekmolloy.ie/writing-a-linux-kernel-module-part-1-introduction/](http://derekmolloy.ie/writing-a-linux-kernel-module-part-1-introduction/)

